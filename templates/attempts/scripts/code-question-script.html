  <!-- Logic to save code snippet every minute -->
  <script>
      const saveCodeSnippet = async () => {
        let formData = new FormData();
        formData.append("code", editor.getValue());
        formData.append("lang-id", langSelect.find("option:selected").data('judgeid'));
        formData.append("csrfmiddlewaretoken", "{{ csrf_token }}");

        // ajax call
        const res = await $.ajax({
            type: 'POST',
            url: '{% url "save-code-attempt-snippet" code_question_attempt_id=question_attempt.id %}',
            data: formData,
            processData: false,
            contentType: false,
        });

        if (res.result === "success") {
          Toastify({
            text: "Code autosaved",
            duration: 3000,
            position: "center",
            style: {"background": "#158754"}
          }).showToast();
        } else {
          Toastify({
            text: "Error autosaving code",
            duration: 3000,
            position: "center",
            style: {"background": "#ff6961"}
          }).showToast();
        }
      };

      window.setInterval(() => {
          saveCodeSnippet();
      }, 60000);
  </script>

  <!-- Ace code editor config -->
  <script>
      const Range = ace.require("ace/range").Range;

      // language and theme selections
      const langSelect = $("#lang-select");
      const themeSelect = $("#theme-select");

      // initialize ace editor
      let editor = ace.edit("editor");
      editor.renderer.setScrollMargin(10);
      editor.setOptions({
          fontFamily: "JetBrains Mono",
          fontSize: "16px",
          theme: "ace/theme/cloud9_day",
          showPrintMargin: false,
          highlightActiveLine: false,
          wrap: true,
          tabSize: 4,
      });
      editor.setOption("dragEnabled", false);

      // when theme dropdown changed
      themeSelect.change(function () {
          editor.setTheme("ace/theme/" + $(this).val());
      });

      const arrowCommands = ["gotoleft", "gotoright", "golineup", "golinedown"];
      let readonlyRanges = [];
      let markers = [];

      const updateReadonlyRanges = () => {
          // clear previous ranges
          readonlyRanges = [];

          // clear previous markers
          markers.forEach((marker) => {
              editor.session.removeMarker(marker);
          });

          const content = editor.getValue().split("\n");
          let starts = [], ends = [];
          content.forEach((line, idx) => {
              if (line.indexOf("// ro-start") !== -1)
                  starts.push(idx);
              else if (line.indexOf("// ro-end") !== -1)
                  ends.push(idx + 1);
          });

          for (let i = 0; i < starts.length; i++) {
              let r = new Range(starts[i], 0, ends[i], 0);
              let marker = editor.session.addMarker(r, "readonly-highlight", "line");
              readonlyRanges.push(r);
              markers.push(marker);
          }
      };

	  const updatePorts = () => {
		return

		// get the selected option
		const selected = langSelect.find("option:selected")

		// get module header
		const wavedrom = JSON.parse(`{{ sample_tc.stdout|safe }}`)

		// iterate through all signals
		let module_header = ""
		wavedrom.signal.forEach((signal, index) => {
			// Determine whether it's an input or output based on the signal name
			const direction = signal.name.startsWith("in_") ? "input" : "output"
			// Remove the 'in_' or 'out_' prefix from the signal name
			const portName = signal.name.replace(/^(in_|out_)/, "")

			// Handle bus declarations
			const busMatch = portName.match(/^(.+)\[(\d+):(\d+)\]$/)
			if (busMatch) {
				const busName = busMatch[1]
				const msb = busMatch[2]
				const lsb = busMatch[3]
				module_header += `${direction} [${msb}:${lsb}] ${busName}`
			} else {
				module_header += `${direction} ${portName}`
			}

			// Add a comma for all but the last port declaration
			if (index !== wavedrom.signal.length - 1) {
				module_header += ", "
			}
		})

		if (module_header) {
			// add read only ranges for module header
			module_header = `// ro-start \nmodule top (${module_header});\n// ro-end`

			// set the code snippet
			lines = selected.data("code").split("\n")
			lines[0] = module_header
			editor.session.setValue(lines.join("\n"))
		}
	}

    // set initial code snippet and language based on latest saved code
    let lastUsedLanguage = '{{ last_used_language|safe }}'
    if (lastUsedLanguage !== "None") {
      const submittedCodeLanguageOption = $("#lang-select option").filter(function () { return $(this).val() === lastUsedLanguage; });
      submittedCodeLanguageOption.prop("selected", true);
      editor.session.setValue(submittedCodeLanguageOption.data("code"));
    } else {
      const selected = langSelect.find("option:selected")
      editor.session.setValue(selected.data("code"))
    }
    let prevLanguage = langSelect.val();

    // function that sets the language and code snippet
    const setLanguage = () => {
      // save code before changing language
      const code = editor.getValue();
      const prevOption = $("#lang-select option").filter(function () { return $(this).val() === prevLanguage; });
      prevOption.data("code", code);
      prevLanguage = langSelect.val();

      // get the selected option
      const selected = langSelect.find("option:selected")
      // set the code snippet
      editor.session.setValue(selected.data("code"))
      
      //"{{ is_software_language }}" === "False" ? updatePorts() : editor.session.setValue(selected.data("code"))
      // set ace mode
      editor.session.setMode("ace/mode/" + selected.data("ace-mode"))

      updateReadonlyRanges()
    }

    // set language on first load
    setLanguage()

    // when language dropdown changed
    langSelect.change(function () {
      setLanguage()
    })

    window.addEventListener("load", function () {
      let wavedrom = JSON.parse(`{{ sample_tc.stdout|safe }}`)
      wavedrom.signal = wavedrom.signal.map((signal) => {
        const nameWithoutPrefix = signal.name.replace(/^in_|^out_/, "")
        signal.name = nameWithoutPrefix
        return signal
      })

      const e = document.getElementById("InputJSON_0")
      e.innerHTML = JSON.stringify(wavedrom)

      // Render the updated waveform
      WaveDrom.RenderWaveForm(0, WaveDrom.eva("InputJSON_0"), "WaveDrom_Display_")
    })

    // prevent action on read-only lines
    editor.commands.on("exec", function (e) {
        // ignore arrow keys commands
        if (arrowCommands.includes(e.command.name))
            return;

        const pos = editor.selection.getCursor();
        readonlyRanges.forEach((readonlyRange) => {
            if (readonlyRange.inside(pos.row, pos.column) || // cursor inside range (exclusive of start and end)
                readonlyRange.isEnd(pos.row, pos.column) && e.command.name === "backspace" ||  // cursor is at the end ( prevent backspace only)
                readonlyRange.isStart(pos.row, pos.column) ||  // cursor is at the start of the range
                !editor.getSelection().isEmpty() && editor.getSelectionRange().intersects(readonlyRange))  // prevent selection containing readonly area but ends in editable area
            {
                e.preventDefault();
                e.stopPropagation();
            }
        });
    });

    editor.commands.on("afterExec", function (e) {
        // ignore arrow keys commands
        if (arrowCommands.includes(e.command.name))
            return;
        updateReadonlyRanges();
    });

    updateReadonlyRanges();
  </script>

  <!-- Reset code editor -->
  <script>
    const resetCode = () => {
      if ({{ assessment_attempt.assessment.limit_tab_switching|yesno:"true,false"}}) {
        window.onblur = () => {};
      }
      
      if (confirm("Are you sure you wish to reset?")) {
        // get the selected option
        const selected = langSelect.find("option:selected")
        // set to initial code snippet
        editor.session.setValue(selected.data("initial-code"))
        
        // set ace mode
        editor.session.setMode("ace/mode/" + selected.data("ace-mode"))
        updateReadonlyRanges()
      }

      if ({{ assessment_attempt.assessment.limit_tab_switching|yesno:"true,false"}}) {
        setTimeout(() => {
          window.onblur = () => { handleTabSwitch(); }
        }, 1000);
      }
    }
  </script>

  <!-- Code running and submission scripts -->
  <script>
      // main elements
      const runStatus = $("#run-status");
      const moreDetails = $("#more-details");
      const mainLoading = $("#main-loading");
      const sampleBtn = $("#sample-btn");
      const submitBtn = $("#submit-btn");
      const waveformBtn = $("#waveform-btn");

      // test case results elements
      const resultsBody = $("#results-body");
      const resultsStdin = $("#results-stdin");
      const resultsStdout = $("#results-stdout");
      const resultsStderrContainer = $("#results-stderr-container");
      const resultsStderr = $("#results-stderr");
      const resultsExpectedOutput = $("#results-expected-output");
      const resultsOutcome = $("#results-outcome");
      const resultsTiming = $("#results-timing");
      const resultsAccordion = $("#results-accordion");
      const resultsHidden = $("#results-hidden");
      const resultsError = $("#results-error")
      const resultsErrorMsg = $("#results-error-msg")

      // submission details modal elements
      const modalToken = $("#m-token");
      const modalLoading = $("#m-loading");
      const modalBody = $("#m-body");
      const modalStdin = $("#m-stdin");
      const modalStdout = $("#m-stdout");
      const modalExpectedOutput = $("#m-expected-output");
      const modalOutcome = $("#m-outcome");
      const modalTiming = $("#m-timing");
      const modalAccordion = $("#m-accordion");
      const modalHidden = $("#m-hidden");
      const modalError = $("#m-error")
      const modalErrorMsg = $("#m-error-msg")

      // vcdrom modal elements
      const vcdromModal = $("#vcdromModal");

      // display error Toast and set status text
      const showError = (msg) => {
          mainLoading.hide();
          moreDetails.hide();

          runStatus.html(msg);
          Toastify({
              text: "An error has occurred, please refresh the page and try again.",
              duration: -1,
              position: "center",
              style: {"background": "#ff6961"}
          }).showToast();
      };

      // display error Toast only
      const showErrorToast = (msg) => {
          Toastify({
              text: msg,
              duration: 3000,
              position: "center",
              style: {"background": "#ff6961"}
          }).showToast();
      };

      // "compile and run" clicked
      const compileAndRun = () => {
          // disable buttons
          sampleBtn.prop("disabled", true);
          submitBtn.prop("disabled", true);

          // hide more details link
          mainLoading.show();
          resultsBody.hide();
          runStatus.html('Submitting');

          // prepare form data
          let formData = new FormData();
          formData.append("code", editor.getValue());
          formData.append("lang-id", langSelect.find("option:selected").data('judgeid'));
          formData.append("csrfmiddlewaretoken", "{{ csrf_token }}");
          formData.append("run_stdin", $("#run-stdin").val());

          // ajax call
          $.ajax({
              type: 'POST',
              url: '{% url "submit-single-test-case" test_case_id=sample_tc.id code_question_id=code_question.id %}',
              data: formData,
              processData: false,
              contentType: false,
          }).done((res, textStatus, jqXHR) => {
              if (res.result === "success") {
                  const token = res.token;
                  updateSampleStatus(token);
              }
          }).fail((jqXHR, textStatus, errorThrown) => {
              window.setTimeout(() => {
                  // 4xx status codes
                  if (Math.floor(jqXHR.status / 100) == 4) {
                      console.error('Internal API error!');
                      showError("Internal API Error &#x274C;");
                  }
                  else {
                      console.error('External API error!');
                      showError("External API Error &#x274C;");
                  }
              }, 1000);
          });
      };

      // updates sample status by polling
      const updateSampleStatus = (token) => {
          $.ajax({
              type: 'GET',
              url: "{% url 'get-tc-details' %}",
              data: {token, status_only: false, vcd: '{{ is_software_language }}' === 'False'},
          }).done((res, textStatus, jqXHR) => {
              if (res.result === "success") {
                  if (res.data.status_id === 1 || res.data.status_id === 2) {  // not finished
                      runStatus.html(res.data.status);
                      window.setTimeout(() => {
                          updateSampleStatus(token);
                      }, 1000);
                  } else { // finished
                      runStatus.html(res.data.status);
                      if (res.data.status_id === 3)
                          resultsOutcome.html(res.data.status + " &#x2705;");
                      else
                          resultsOutcome.html(res.data.status + " &#x274C;");

                      // hide waveforms
                      resultsTiming.addClass("d-none")
                      resultsAccordion.addClass("d-none")
                      resultsHidden.addClass("d-none")
                      resultsError.addClass("d-none")

                      // set values
                      resultsStdin.html(res.data.stdin ? res.data.stdin : '&nbsp;');

                      if ('{{ is_software_language }}' === 'True') {
                        resultsStdout.html(res.data.stdout ? res.data.stdout : '&nbsp;');
                        resultsExpectedOutput.html(res.data.expected_output ? res.data.expected_output : '&nbsp;');
                        if (res.data.stderr != undefined) {
                          resultsStderrContainer.show();
                          resultsStderr.html(res.data.stderr);
                        } else if (res.data.compile_output != undefined) {
                          resultsStderrContainer.show();
                          resultsStderr.html(res.data.compile_output);
                        } else {
                          resultsStderrContainer.hide();
                        }
                      } else {
                        if (res.data.stdout && res.data.stdout !== 'Hidden') {
                          // show waveforms
                          resultsAccordion.removeClass("d-none")

                          const wavedromGroups = compareWaveform(res.data.expected_output, res.data.stdout)

                          wavedromGroups.forEach((wavedrom, index) => {
                            // update accordion header
                            const accordionHeader = document.getElementById(`waveformHeading${index + 1}`);
                            const accordionButton = accordionHeader.querySelector('.accordion-button');
                            let title

                            if (wavedrom.signal[6].wave.includes('h'))
                              title = `${wavedrom.signal[2][1].name}<span style="margin-left: 30px">&#x274C;</span>`
                            else
                              title = `${wavedrom.signal[2][1].name}<span style="margin-left: 30px">&#x2705;</span>`
                            
                            accordionButton.innerHTML = title;

                            // update waveform
                            const resultsWavedrom = document.getElementById(`InputJSON_${index + 1}`)
                            resultsWavedrom.innerHTML = JSON.stringify(wavedrom)
                            WaveDrom.RenderWaveForm(index + 1, WaveDrom.eva(`InputJSON_${index + 1}`), "WaveDrom_Display_")
                          })
                        } else if (res.data.stdout === 'Hidden') {
                          // show hidden
                          resultsTiming.addClass("d-none")
                          resultsHidden.removeClass("d-none")
                        } else if (res.data.status_id === 6) {  // compilation error
                          // hide timing diagram
                          resultsTiming.addClass("d-none")

                          // show error message
                          resultsError.removeClass("d-none")
                          resultsErrorMsg.html(res.data.compile_output)
                        } else {
                          // show error message
                          resultsError.removeClass("d-none")
                          resultsErrorMsg.html(res.data.stderr)
                        }
                      }

                      resultsBody.show();
                        // enable buttons
                      sampleBtn.prop("disabled", false);
                      submitBtn.prop("disabled", false);
                      // hide loading
                      mainLoading.hide();
                      // set waveform button if compilation successful
                      if ((res.data.status_id === 3 | res.data.status_id === 4) && '{{ is_software_language }}' === 'False') {
                        waveformBtn.data('vcd', res.data.vcd_output);

                        // show waveform button
                        waveformBtn.removeClass('d-none');
                      }
                  }
              }
          }).fail((jqXHR, textStatus, errorThrown) => {
              // 4xx status codes
              if (Math.floor(jqXHR.status / 100) == 4) {
                  console.error("Internal API Error!");
                  showError("Internal API Error &#x274C;");
              }
              else {
                  console.error("External API Error!");
                  showError("External API Error &#x274C;");
              }
          });
      }

      // "view waveform" clicked
      const viewWaveform = () => {
        const vcd = waveformBtn.data('vcd');
        if (!vcd) {
          showErrorToast("An error has occurred. Please check that you have successfully compiled your code and try again.");
          return;
        }

        // disable buttons
        sampleBtn.prop("disabled", true);
        submitBtn.prop("disabled", true);

        $.ajax({
          type: 'POST',
          url: "{% url 'vcdrom' %}",
          data: {vcd: vcd, csrfmiddlewaretoken: "{{ csrf_token }}"},
        }).done((res, textStatus, jqXHR) => {
          var iframeDocument = modalIframe.contentDocument || modalIframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(res);
          iframeDocument.close();
          vcdromModal.modal('show');
        }).fail((jqXHR, textStatus, errorThrown) => {
          // 4xx status codes
          if (Math.floor(jqXHR.status / 100) == 4) {
              console.error("Internal API Error!");
              showError("Internal API Error &#x274C;");
          }
          else {
              console.error("External API Error!");
              showError("External API Error &#x274C;");
          }
        });

        // enable buttons when modal close
        vcdromModal.on('hidden.bs.modal', () => {
          sampleBtn.prop("disabled", false);
          submitBtn.prop("disabled", false);
        });
      }

      const compareWaveform = (expectedWave, studentWave) => {
        const expectedSignals = JSON.parse(expectedWave).signal
        const studentSignals = JSON.parse(studentWave).signal

        const expectedOutput = expectedSignals.filter((signal) => signal.name.startsWith('out_'))
        const studentOutput = studentSignals.filter((signal) => signal.name.startsWith('out_'))

        const waveformGroups = []

        // Generate mismatch signal
        expectedOutput.forEach((signal, index) => {
          const mismatch = generateMismatch(expectedOutput[index], studentOutput[index])
          const groupedSignals = {signal: [['Input'], {}, ['Yours'], {}, ['Ref'], {}, {'name': 'Mismatch', 'wave': ''}], foot: {tick: 0, every: 5} }
          groupedSignals.signal[6]['wave'] = mismatch
          waveformGroups.push(groupedSignals)
        })

        expectedOutput.forEach((signal, index) => {
          signal.name = signal.name.replace(/^(out_)/, '');
          waveformGroups[index].signal[4].push(signal);
        })

        // Group signals by input and output
        expectedSignals.forEach((signal) => {
          const direction = signal.name.startsWith('in_') ? 'Input' : 'Yours';
          signal.name = signal.name.replace(/^(in_|out_)/, '');

          if (direction === 'Input') {
            // Push to every waveform group
            waveformGroups.forEach((group) => {
              group.signal[0].push(signal)
            })
          }
        })

        studentOutput.forEach((signal, index) => {
          signal.name = signal.name.replace(/^(out_)/, '');
          waveformGroups[index].signal[2].push(signal)
        })

        return waveformGroups
      }

      const generateMismatch = (expectedOutput, studentOutput) => {
        // compare the two outputs
        const expectedWave = expectedOutput.wave
        const studentWave = studentOutput.wave
        const expectedData = expectedOutput.data
        const studentData = studentOutput.data

        const mismatch = {'name': 'Mismatch'}
        let mismatchWave = ''
        let counter = 0 // counter to track data index
        let currentMismatch = 'low'

        let expectedArr = []
        let studentArr = []

        // convert all '.' to previous value
        expectedWave.split('').forEach((char, index) => {
          if (char === '.') {
          expectedArr.push(expectedArr[index - 1])
          } else if (char === '=') {
          expectedArr.push(expectedData[counter])
          counter++
          } else {
          expectedArr.push(char)
          }
        })

        counter = 0

        studentWave.split('').forEach((char, index) => {
          if (char === '.') {
          studentArr.push(studentArr[index - 1])
          } else if (char === '=') {
          studentArr.push(studentData[counter])
          counter++
          } else {
          studentArr.push(char)
          }
        })

        // compare the two strings to generate mismatch
        for (let i = 0; i < expectedArr.length; i++) {
          if (expectedArr[i] === 'x' || studentArr[i] === 'x') {
            i === 0 ? mismatchWave += 'l' : currentMismatch === 'low' ? mismatchWave += '.' : mismatchWave += 'l'
            currentMismatch = 'low'
          } else if (expectedArr[i] === studentArr[i]) {
          i === 0 ? mismatchWave += 'l' : currentMismatch === 'low' ? mismatchWave += '.' : mismatchWave += 'l'
          currentMismatch = 'low'
          } else {
          i === 0 ? mismatchWave += 'h' : currentMismatch === 'high' ? mismatchWave += '.' : mismatchWave += 'h'
          currentMismatch = 'high'
          }
        }

        return mismatchWave
      }

      // "More Details" or "Test Case x" clicked (opens modal)
      const viewModal = (btn) => {
          // get token
          const token = $(btn).data('token');

          // show m-loading, hide m-body
          modalBody.hide();
          modalLoading.show();

          // hide waveforms
          modalTiming.addClass("d-none")
          modalAccordion.addClass("d-none")
          modalHidden.addClass("d-none")
          modalError.addClass("d-none")

          // ajax request
          $.ajax({
              type: 'GET',
              url: "{% url 'get-tc-details' %}",
              data: {token, status_only: false},
          }).done((res, textStatus, jqXHR) => {
              if (res.result === "success") {
                  // set values
                  modalToken.html(token);
                  modalStdin.html(res.data.stdin ? res.data.stdin : '&nbsp;');
                  modalOutcome.html(res.data.status);

                  if ('{{ is_software_language }}' === 'True') {
                    modalStdout.html(res.data.stdout ? res.data.stdout : '&nbsp;');
                    modalExpectedOutput.html(res.data.expected_output ? res.data.expected_output : '&nbsp;');
                  } else {
                    if (res.data.stdout && res.data.stdout !== 'Hidden') {
                      // show waveforms
                      modalAccordion.removeClass("d-none")

                      const wavedromGroups = compareWaveform(res.data.expected_output, res.data.stdout)

                      wavedromGroups.forEach((wavedrom, index) => {
                        // update accordion header
                        const accordionHeader = document.getElementById(`waveformHeading${index + 1}`);
                        const accordionButton = accordionHeader.querySelector('.accordion-button');
                        let title

                        if (wavedrom.signal[6].wave.includes('h'))
                          title = `${wavedrom.signal[2][1].name}<span style="margin-left: 30px">&#x274C;</span>`
                        else
                          title = `${wavedrom.signal[2][1].name}<span style="margin-left: 30px">&#x2705;</span>`
                        
                        accordionButton.innerHTML = title;

                        // update waveform
                        const modalWavedrom = document.getElementById(`InputJSON_${index + 1}`)
                        modalWavedrom.innerHTML = JSON.stringify(wavedrom)
                        WaveDrom.RenderWaveForm(index + 1, WaveDrom.eva(`InputJSON_${index + 1}`), "WaveDrom_Display_")
                      })
                    } else if (res.data.stdout === 'Hidden') {
                      // show hidden
                      modalTiming.addClass("d-none")
                      modalHidden.removeClass("d-none")
                    } else if (res.data.status_id === 6) {  // compilation error
                      // hide timing diagram
                      modalTiming.addClass("d-none")

                      // show error message
                      modalError.removeClass("d-none")
                      modalErrorMsg.html(res.data.compile_output)
                    } else {
                      // show error message
                      modalError.removeClass("d-none")
                      modalErrorMsg.html(res.data.stderr)
                    }
                  }

                  setTimeout(() => {
                      modalLoading.hide();
                      modalBody.show();
                  }, 500);
              }
          }).fail((jqXHR, textStatus, errorThrown) => {
              // 4xx status codes
              if (Math.floor(jqXHR.status / 100) == 4) {
                console.error("Internal API Error!");
              }
              else {
                console.error("External API Error!");
              }
          });

          // show modal
          $('#detailsModal').modal('show');
      };

      // submit code, create new submission
      const submit = () => {
          saveCodeSnippet();
          
          // disable buttons
          sampleBtn.prop("disabled", true);
          submitBtn.prop("disabled", true);

          // hide more details link
          mainLoading.show();
          moreDetails.hide();
          runStatus.html('Submitting');

          // prepare form data
          let formData = new FormData();
          formData.append("code", editor.getValue());
          formData.append("lang-id", langSelect.find("option:selected").data('judgeid'));
          formData.append("csrfmiddlewaretoken", "{{ csrf_token }}");
          formData.append("start_time", "{{ start_time }}");

          // ajax call
          $.ajax({
              type: 'POST',
              url: "{% url 'code-question-submission' code_question_attempt_id=question_attempt.id %}",
              data: formData,
              processData: false,
              contentType: false,
          }).done((res, textStatus, jqXHR) => {
              if (res.result === "success") {
                  setTimeout(() => {
                      // update status
                      runStatus.html('Processing');

                      // add accordion
                      const clonedAccordionItem = $("#accordion-item-template").clone();
                      clonedAccordionItem.removeAttr('id style');
                      clonedAccordionItem.html(
                          $(clonedAccordionItem).html().replaceAll('__cqs_id__', res.cqs_id).replaceAll('__time_submitted__', res.time_submitted)
                      );

                      res.statuses.forEach((value, idx) => {
                          const clonedTestCase = $("#test-case-template").clone();
                          clonedTestCase.removeAttr('id style');
                          clonedTestCase.html(
                              $(clonedTestCase).html().replaceAll('__tca_id__', value[0]).replaceAll('__idx__', idx + 1).replaceAll('__token__', value[2])
                          );
                          clonedAccordionItem.find(`#submission-${res.cqs_id} > div > div`).append(clonedTestCase);
                      });
                      $("#submissions-accordion").prepend(clonedAccordionItem);
                      $("#submission-" + res.cqs_id).collapse('show');
                      // call updator function
                      updateSubmissionStatus(res.cqs_id, 0);
                  }, 500);
              }
          }).fail((jqXHR, textStatus, errorThrown) => {
              // 4xx status codes
              if (Math.floor(jqXHR.status / 100) == 4) {
                  console.error("Internal API Error!");
                  showError("Internal API Error &#x274C;");
              }
          })
      };

      // polls and updates the status of a submission and its testcases
      const updateSubmissionStatus = (cqs_id, attempts) => {
          // ajax request
          $.ajax({
              type: 'GET',
              url: "{% url 'get-cq-submission-status' %}",
              data: {cqs_id},
          }).done((res, textStatus, jqXHR) => {
              if (res.result === "success") {
                  // set submission status (passed/failed/processing)
                  setSubmissionStatus(res.cqs_id, res.outcome);

                  // set testcase statuses
                  res.statuses.forEach((value) => {
                      setTestCaseStatus(value[0], value[1]);
                  });

                  // if submission is still processing, poll again in 1s
                  if (res.outcome === "Processing") {
                      if (attempts >= 8) {
                        setSubmissionStatus(cqs_id, "Timed Out");
                        res.statuses.forEach((value) => {
                          setTestCaseStatus(value[0], 5);
                        });
                      } else {
                        window.setTimeout(() => {
                          updateSubmissionStatus(cqs_id, attempts + 1);
                      }, 1000);
                      }
                  }
              }
          }).fail((jqXHR, textStatus, errorThrown) => {
              // 4xx status codes
              if (Math.floor(jqXHR.status / 100) == 4) {
                  console.error("Internal API Error!");
                  showError("Internal API Error &#x274C;");
              }
              else {
                  error("External API Error!");
                  showError("External API Error &#x274C;");
              }
          });
      };

      const setSubmissionStatus = (cqs_id, outcome) => {
          const cqsStatus = $("#cqs-status-" + cqs_id);

          cqsStatus.html(outcome);
          cqsStatus.removeClass("bg-light-danger bg-light-success bg-light-warning");
          if (outcome === "Processing") {
              cqsStatus.addClass("bg-light-warning");
              return;
          } else if (outcome === "Passed")
              cqsStatus.addClass("bg-light-success");
          else if (outcome === "Failed" || outcome === "Timed Out")
              cqsStatus.addClass("bg-light-danger");

          // enable buttons
          sampleBtn.prop('disabled', false);
          submitBtn.prop('disabled', false);
          runStatus.html('Ready');
          mainLoading.hide();
      };

      const setTestCaseStatus = (tca_id, status_id) => {
          const loading = $("#tca-loading-" + tca_id);
          const failed = $("#tca-failed-" + tca_id);
          const accepted = $("#tca-accepted-" + tca_id);

          if (status_id === 1 || status_id === 2) { // loading
              loading.show();
              failed.hide();
              accepted.hide();
          } else if (status_id === 3) { // accepted
              loading.hide();
              failed.hide();
              accepted.show();
              $("#tca-" + tca_id).removeClass("disabled");
          } else {  // failed
              loading.hide();
              failed.show();
              accepted.hide();
              $("#tca-" + tca_id).removeClass("disabled");
          }
      };

      // handle ongoing submissions upon page load
      {% for cqs in code_question_submissions %}
          {% if cqs.outcome == "Processing" %}
              updateSubmissionStatus({{cqs.id}}, 0);
              // disable buttons and set status
              sampleBtn.prop("disabled", true);
              submitBtn.prop("disabled", true);
              runStatus.html('Processing');
          {% endif %}
      {% endfor %}
</script>